{"ast":null,"code":"import { ethers } from \"ethers\";\nimport PropertyNFT from \"./PropertyNFT.json\"; // ABI from Hardhat artifacts\n\nconst CONTRACT_ADDRESS = \"PASTE_DEPLOYED_CONTRACT_ADDRESS_HERE\";\nexport async function getProvider() {\n  if (window.ethereum) {\n    await window.ethereum.request({\n      method: \"eth_requestAccounts\"\n    });\n    return new ethers.providers.Web3Provider(window.ethereum);\n  }\n  throw new Error(\"MetaMask not found\");\n}\nexport async function getSigner() {\n  const provider = await getProvider();\n  return provider.getSigner();\n}\nexport async function getContract() {\n  const signer = await getSigner();\n  return new ethers.Contract(CONTRACT_ADDRESS, PropertyNFT.abi, signer);\n}\nexport async function getMyNFTs(address) {\n  const contract = await getContract();\n  const balance = await contract.balanceOf(address);\n  let nfts = [];\n  for (let i = 0; i < balance; i++) {\n    const tokenId = await contract.tokenOfOwnerByIndex(address, i);\n    const data = await contract.getProperty(tokenId);\n    nfts.push({\n      tokenId: tokenId.toString(),\n      ...parsePropertyData(data)\n    });\n  }\n  return nfts;\n}\nfunction parsePropertyData([itemType, name, value, purchaseDate, vin, addr]) {\n  return {\n    itemType,\n    name,\n    value: value.toString(),\n    purchaseDate,\n    vin,\n    addr\n  };\n}\n\n// Create an offer for a buyer to purchase an NFT\nexport async function createOffer(tokenId, buyer, priceEth) {\n  const contract = await getContract();\n  // Convert ETH to wei\n  const price = ethers.utils.parseEther(priceEth);\n  const tx = await contract.createOffer(tokenId, buyer, price);\n  await tx.wait();\n}\n\n// Get pending offers for the current account\nexport async function getPendingOffers(address) {\n  const contract = await getContract();\n  const offers = await contract.getPendingOffers(address);\n  // Parse Offer struct array\n  return offers.map(o => ({\n    offerId: o.offerId.toString(),\n    tokenId: o.tokenId.toString(),\n    seller: o.seller,\n    buyer: o.buyer,\n    price: ethers.utils.formatEther(o.price),\n    active: o.active\n  }));\n}\n\n// Accept an offer as the buyer (send ETH)\nexport async function acceptOffer(offerId, priceEth) {\n  const contract = await getContract();\n  const overrides = {\n    value: ethers.utils.parseEther(priceEth)\n  };\n  const tx = await contract.acceptOffer(offerId, overrides);\n  await tx.wait();\n}\n\n// Get ETH balance for any address\nexport async function getEthBalance(address) {\n  if (!address || typeof address !== \"string\" || !address.startsWith(\"0x\") || address.length !== 42) {\n    return \"0\";\n  }\n  const provider = await getProvider();\n  // Try-catch in case something weird sneaks through\n  try {\n    const bal = await provider.getBalance(address);\n    return ethers.utils.formatEther(bal);\n  } catch (e) {\n    return \"0\";\n  }\n}","map":{"version":3,"names":["ethers","PropertyNFT","CONTRACT_ADDRESS","getProvider","window","ethereum","request","method","providers","Web3Provider","Error","getSigner","provider","getContract","signer","Contract","abi","getMyNFTs","address","contract","balance","balanceOf","nfts","i","tokenId","tokenOfOwnerByIndex","data","getProperty","push","toString","parsePropertyData","itemType","name","value","purchaseDate","vin","addr","createOffer","buyer","priceEth","price","utils","parseEther","tx","wait","getPendingOffers","offers","map","o","offerId","seller","formatEther","active","acceptOffer","overrides","getEthBalance","startsWith","length","bal","getBalance","e"],"sources":["C:/Users/Rares Manolescu/Desktop/blockchain-property-app/frontend/src/contractUtils.js"],"sourcesContent":["import { ethers } from \"ethers\";\r\nimport PropertyNFT from \"./PropertyNFT.json\"; // ABI from Hardhat artifacts\r\n\r\nconst CONTRACT_ADDRESS = \"PASTE_DEPLOYED_CONTRACT_ADDRESS_HERE\";\r\n\r\nexport async function getProvider() {\r\n  if (window.ethereum) {\r\n    await window.ethereum.request({ method: \"eth_requestAccounts\" });\r\n    return new ethers.providers.Web3Provider(window.ethereum);\r\n  }\r\n  throw new Error(\"MetaMask not found\");\r\n}\r\n\r\nexport async function getSigner() {\r\n  const provider = await getProvider();\r\n  return provider.getSigner();\r\n}\r\n\r\nexport async function getContract() {\r\n  const signer = await getSigner();\r\n  return new ethers.Contract(CONTRACT_ADDRESS, PropertyNFT.abi, signer);\r\n}\r\n\r\nexport async function getMyNFTs(address) {\r\n  const contract = await getContract();\r\n  const balance = await contract.balanceOf(address);\r\n  let nfts = [];\r\n  for (let i = 0; i < balance; i++) {\r\n    const tokenId = await contract.tokenOfOwnerByIndex(address, i);\r\n    const data = await contract.getProperty(tokenId);\r\n    nfts.push({\r\n      tokenId: tokenId.toString(),\r\n      ...parsePropertyData(data)\r\n    });\r\n  }\r\n  return nfts;\r\n}\r\n\r\nfunction parsePropertyData([itemType, name, value, purchaseDate, vin, addr]) {\r\n  return {\r\n    itemType, name, value: value.toString(), purchaseDate, vin, addr\r\n  };\r\n}\r\n\r\n// Create an offer for a buyer to purchase an NFT\r\nexport async function createOffer(tokenId, buyer, priceEth) {\r\n  const contract = await getContract();\r\n  // Convert ETH to wei\r\n  const price = ethers.utils.parseEther(priceEth);\r\n  const tx = await contract.createOffer(tokenId, buyer, price);\r\n  await tx.wait();\r\n}\r\n\r\n// Get pending offers for the current account\r\nexport async function getPendingOffers(address) {\r\n  const contract = await getContract();\r\n  const offers = await contract.getPendingOffers(address);\r\n  // Parse Offer struct array\r\n  return offers.map(o => ({\r\n    offerId: o.offerId.toString(),\r\n    tokenId: o.tokenId.toString(),\r\n    seller: o.seller,\r\n    buyer: o.buyer,\r\n    price: ethers.utils.formatEther(o.price),\r\n    active: o.active\r\n  }));\r\n}\r\n\r\n// Accept an offer as the buyer (send ETH)\r\nexport async function acceptOffer(offerId, priceEth) {\r\n  const contract = await getContract();\r\n  const overrides = {\r\n    value: ethers.utils.parseEther(priceEth)\r\n  };\r\n  const tx = await contract.acceptOffer(offerId, overrides);\r\n  await tx.wait();\r\n}\r\n\r\n// Get ETH balance for any address\r\nexport async function getEthBalance(address) {\r\n    if (\r\n      !address ||\r\n      typeof address !== \"string\" ||\r\n      !address.startsWith(\"0x\") ||\r\n      address.length !== 42\r\n    ) {\r\n      return \"0\";\r\n    }\r\n    const provider = await getProvider();\r\n    // Try-catch in case something weird sneaks through\r\n    try {\r\n      const bal = await provider.getBalance(address);\r\n      return ethers.utils.formatEther(bal);\r\n    } catch (e) {\r\n      return \"0\";\r\n    }\r\n  }\r\n  \r\n  \r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}